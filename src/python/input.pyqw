[main]
; specify the fortran library to use if Fortran functions/lapack are used:
;	intel (default) - this uses intel-mkl, generally faster than lapack
;	gcc - uses BLAS/LAPACK, more common than intel-mkl 
fortran = intel
; choose the library used to calculate the eigenvalues:
;	lapack (default) - requires either intel-mkl or LAPACK be installed
;	python-scipy - this uses ARPACK bindings
;	python-numpy
eig_lib	= lapack
; choose the eigenvalue solver algorithm:
;	general - uses a general complex algorithm
;	SH (default) - uses an algorithm tailored for symmetric Hermitian band matrices
eig_solver = SH


[ctqw parameters]
; simulation settings
particles = 2
grid_length = 200
time = 10.0
; set the location of the defect
; nodes and the respective amplitudes.
; 	Note that both lists must be
;	the same length!
defect_nodes = [3 , 4]
defect_amp = [2.,1.5]
; set the initial state of the walker.
; For 1 walker, this is of the form
;	[(J1,AMP1), (J2,AMP2),...]
; For 2 walkers, this is of the form
;	[(X1,Y1,AMP1), (X2,Y2,AMP2),...]
p1_initial_state = [(0,1/sqrt(2)), (1,1j/sqrt(2))]
p2_initial_state = [(0,0,1/sqrt(2)), (1,1,1/sqrt(2))]
; Alternatively, set the location of an input 
; statespace. For 1P, this is a textfile with
; dimensions GRID_LENGTH*1; for 2P, this is a
; textfile with dimensions GRID_LENGTH*GRID*LENGTH
;	NOTE: this overides p*_initial_state
input_state = 


[ctqw options]
; choose the Hamiltonian is created/stored:
;	fortran-dense (default)
;	python-dense
;	python-sparse (uses SciPy and ARPACK to create sparse matrices)
; 		NOTE: python-sparse requires either 
;		1) propagator=python-chebyshev and eig-lib=python-scipy
;		2) propagator=python-expm (only for SciPy > version 0.12.0)
matrix_form = python-sparse
; choose the algorithm used to calculate CTQW propagation:
;	fortran-chebyshev (default),
;	fortran-burkadt
;	python-chebyshev
;	python-expm
; Note that the Burkadt	and python-expm methods do NOT require an eigenvalue solver
propagator = fortran-chebyshev


[output]
; set output settings
; output directory
output = ./out
; whether the final statespace is
; outputted in the case of a 2pQW
statespace = true



[matrix exp]
; to enter matrix exp mode, run './pyctqw expm'
;
; the nxn matrix to exponentiate, as well as the dimension n.
; This can be provided either in the form of a dense matrix:
;	matrix = [[1,2j,0],[1,0,-0.2],[1,1j,0]]
; or in the form of a sparse matrix:
;	matrix = [(0,0,A_00),...,(i,j,A_ij),...]
; Alternatively, the keywords random_real
;	random_complex
;	hamiltonian
;	hamiltonian2D
; can be used. Note that if eig_solver=SH is set, then the random
; matrix creation functions automatically create Hermitian matrices
leading_dim = 1000
matrix = random_complex
; Alternatively, the matrix can be imported
; in either dense matrix (table) form or sparse CSC form
input_matrix = 
; in Matrix Exp mode, choose the algorithm to calculate the matrix exponential
sparse_alg = False
